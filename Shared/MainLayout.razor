@using Grpc.Core;
@using Grpc.Net.Client;
@using Grpc.Net.Client.Web;
@using LibSeedy;
@using Microsoft.Win32.SafeHandles
@inherits LayoutComponentBase

<div class="page">
    
<MudThemeProvider />

<MudLayout>
    <MudAppBar Elevation="1">
        <MudText Typo="Typo.h5" Class="ml-3">Seedly</MudText>
        <MudSpacer />
        <MudIconButton Icon="@Icons.Material.Filled.MoreVert" Color="Color.Inherit" Edge="Edge.End" />
    </MudAppBar>
    <MudMainContent>
        <MudGrid Spacing="3" Justify="Justify.FlexStart">
            <MudItem xs="12">
                <MudTextField  @bind-Value="Search" Label="Search" Variant="Variant.Outlined" Adornment="Adornment.End" AdornmentIcon="@Icons.Material.Filled.Search" AdornmentColor="Color.Secondary" 
                               OnKeyDown="@Callback"/>
            </MudItem>
            <MudItem xs="12">
                <h3>Completed Items</h3>
                <MudList>
                    @foreach (var item in CompletedItems.Take(5))
                    {
                        if (item.status == Status.Success)
                        {
                            <MudListItem Avatar="@Icons.Material.Filled.Check">
                                @item.magnet_url
                            </MudListItem>
                        }
                        else if (item.status == Status.Fail)
                        {
                            <MudListItem Avatar="@Icons.Material.Filled.Cancel">
                                @item.magnet_url
                            </MudListItem>
                        }
                    }
                </MudList>
            </MudItem>
            <MudItem xs="12">
                <h3>
                    Current Items:
                </h3>
                <MudStack>
                    @foreach (var item in items)
                    {
                        <MudItem>
                            <MudStack Row="true">
                                <MudItem>@item.magnet_url</MudItem>
                                <MudProgressLinear Color="Color.Success" Striped="true" Size="Size.Large" Value="@item.progress_value" Min="0" Max="100">
                                    <MudText Typo="Typo.subtitle1" Color="Color.Dark">
                                        <b>@item.progress_value.ToString()%</b>
                                    </MudText>
                                </MudProgressLinear>
                            </MudStack>
                        </MudItem>
                    }
                </MudStack>
            </MudItem>
        </MudGrid>
    </MudMainContent>
</MudLayout>

    @code {
        public string Search { get; set;}
        public List<DownloadItem> items = new List<DownloadItem>();
        public HttpClient Client = new HttpClient();
        public List<DownloadItem> CompletedItems = new List<DownloadItem>();

        public enum Status
        {
            Downloading,
            Success,
            Fail
        }
        public class DownloadItem
        {
            public string magnet_url { get; set; }
            public int progress_value { get; set; }
            public bool _disposed;
            public void Dispose() => _disposed = true;
            public Status status { get; set; }
            public DownloadItem(string url, Status stat)
            {
                magnet_url = url;
                progress_value = 0;
                status = stat;
            }
        }
        private async void Callback(KeyboardEventArgs obj)
        {
            if ((obj.Key == "Enter" || obj.Key == "NumpadEnter") && /*!items.Any(x => x.magnet_url.Equals(Search)) &&*/ !string.IsNullOrEmpty(Search))
            {
                items.Add(new DownloadItem(Search, Status.Downloading));
                StateHasChanged();
                await SimulateProgress();
            }
        }

        public async Task SimulateProgress()
        {

            //var channel = new Channel("localhost:50051", ChannelCredentials.Insecure);
            AppContext.SetSwitch("System.Net.Http.SocketsHttpHandler.Http2UnencryptedSupport", true);
            AppContext.SetSwitch("System.Net.Http.SocketsHttpHandler.Http2Support", false);

            var httpHandler = new GrpcWebHandler(GrpcWebMode.GrpcWeb, new HttpClientHandler());
            var channel = GrpcChannel.ForAddress("http://localhost:50051", new GrpcChannelOptions
            {
                HttpHandler = httpHandler
            });

            var client = new WeatherForecast.WeatherForecasts.WeatherForecastsClient(channel);

            var item = items.Last();
            item.progress_value = 0;

            // Prepare the request
            var request = new WeatherForecast.DownloadRequest
            { 
                Url = item.magnet_url
            };

            // Create a call to the server streaming method
            using (var call = client.GetUpdateStream(request))
            {
                try
                {
                    await foreach (var response in call.ResponseStream.ReadAllAsync())
                    {
                        //Console.WriteLine("Received number: " + response.ProgressInt);
                        item.progress_value = response.ProgressInt;
                        StateHasChanged();
                        await Task.Delay(1);
                    }
                    item.status = Status.Success;
                }
                catch (RpcException ex) when (ex.Status.StatusCode == StatusCode.Cancelled)
                {
                    Console.WriteLine("The server stream was canceled.");
                    item.status = Status.Fail;
                }
                finally
                {
                    CompletedItems.Add(item);
                    items.Remove(item);
                    StateHasChanged();
                    await Task.Delay(1);
                }
            }

            Console.WriteLine("Press any key to exit...");
            Console.ReadKey();
    }

}
</div>